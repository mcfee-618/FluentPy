## 引用式变量

* Python 变量类似于 Java 中的引用式变量，变量引用一个实际的对象，创建对象之后才会把变量分配给对象。

* 标识：变量都有标识、类型和值。对象一旦创建，它的标识绝不会变；你可以把标识理解为对象在内存中的地址。is运算符比较两个对象的标识；id() 函数返回对象标识的整数表示。在 CPython 中，id()返回对象的内存地址，但是在其他Python解释器中可能是别的值。关键是ID一定是唯一的数值标注，而且在对象的生命周期中绝不会变。编程中很少使用 id() 函数。标识最常使用 is 运算符检查，而不是直接比较 ID。

* == 和 is：== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。is 运算符比 == 速度快，因为它不能重载，而 a == b 是语法糖，等同于 a.__eq__(b),自定义类型需要覆写这个方法。继承自 object 的 __eq__方法比较两个对象的 ID，结果与 is 一样。

* 元组的相对不可变性：元组与多数 Python 集合（列表、字典、集，等等）一样，保存的是对象的引用。如果引用的元素是可变的，即便元组本身不可变，元素依然可变。也就是说，元组的不可变性其实是指 tuple 数据结构的的引用不可变，引用的元素是可变的。

## 深复制和浅复制

* 浅复制：对列表和其他可变序列来说，还能使用简洁的 l2 = l1[:] 语句创建副本，不过这种方法做的是浅复制 （即复制了最外层容器，副本中的元素是源容器中元素的引用）。
```
对可变的对象来说+= 运算符就地修改列表。
对元组来说，+= 运算符创建一个新元组，然后重新绑定给元祖的引用变量 。
```
* 浅复制没什么问题，但有时我们需要的是深复制 （即副本不共享内部对象的引用）。copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制。

* 可视化展示：http://www.pythontutor.com/visualize.html#mode=edit


## 函数的参数作为引用时
函数可能会修改作为参数传入的可变对象，不要使用可变类型作为参数的默认值,两个原因：

* list是一个可变对象，可以在不修改其内存地址的情况下修改其所包含的元素。

* 函数的默认值是在定义函数时计算(通常是加载模块时)，因此默认值变成了函数的对象属性。而不是我们认为的每次调用函数只要不给参数就会计算一次默认值，每次默认值都是[]，简单来说就是函数的形参c只是在函数定义的时候进行一次默认赋值：c=[]，在函数调用的时，如果不传参数，形参c不会进行赋值操作。

优化方案：使用不可变对象或者None作为参数的默认值

## del和垃圾回收

* 对象绝不会自行销毁，然而，无法得到对象时，可能会被当作垃圾回收。del语句删除的是对象的引用，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。
```
如果两个对象相互引用，当它们的引用只存在二者之间时，垃圾回收程序会判定它们都无法获取，进而把它们都销毁。
__del__() 方法用于销毁Python对象——在任何Python对象将被系统回收的时候，系统都会自动调用这个方法。
Python 解释器会调用 __del__ 方法，给实例最后的机会，释放外部资源。
```

* 引用计数：在CPython中，垃圾回收使用的主要算法是引用计数。实际上，每个对象都会统计有多少引用指向自己。当引用计数 归零时，对象立即就被销毁。CPython 会在对象上调用 __del__ 方法（如果定义了），然后释放分配给对象的内存。

    ```
    使用sys.getrefcount()函数查看引用次数，在使用sys.getrefcount()函数时，函数会引用一次
    所以会比预期的引用次数多1
    ```

* 标记清除：标记清除算法作为Python的辅助垃圾收集技术，主要处理的是一些容器对象，比如list、dict、tuple等，因为对于字符串、数值对象是不可能造成循环引用问题。它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。

* 分代回收：分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。

* TODO各个垃圾回收算法的优缺点

## 弱引用

* 弱引用不会增加对象的引用数量，不会妨碍所指对象（referent）被当作垃圾回收。弱引用在缓存应用中很有用，因为我们不想仅因为被缓存引用着而始终保存缓存对象。当对像的引用只剩弱引用时， garbage collection 可以销毁引用并将其内存重用于其他内容。但是，在实际销毁对象之前，即使没有强引用，弱引用也一直能返回该对象。

* class weakref.ref(object[, callback])返回对 对象 的弱引用。如果原始对象仍然存活，则可以通过调用引用对象来检索原始对象；如果引用的原始对象不再存在，则调用引用对象将得到 None 。weakref.ref 类其实是低层接口，供高级用途使用，多数程序最好使用 weakref 集合和 finalize 。class weakref.finalize(obj, func, *args, **kwargs)
返回一个可调用的终结器对象，该对象将在 obj 作为垃圾回收时被调用。 与普通的弱引用不同，终结器将总是存活，直到引用对象被回收，这极大地简化了生存期管理。

* weakref集合:WeakValueDictionary 类实现的是一种可变映射，里面的值是对象的弱引用。被引用的对象在程序中的其他地方被当作垃圾回收后，对应的键会自动从 WeakValueDictionary 中删除。因此，WeakValueDictionary 经常用于缓存。WeakKeyDictionary与之对应，它存储的键是对象的弱引用。weakref 模块还提供了 WeakSet 类，按照文档的说明，这个类的作用很简单：“保存元素弱引用的集合类。元素没有强引用时，集合会把它删除。

    * 弱引用的局限：不是每个 Python 对象都可以作为弱引用的目标（或称所指对象）。基本的 list 和 dict 实例不能作为所指对象，但是它们的子类可以轻松地解决这个问题
    
* 某些情况下，可能需要保存对象的引用，但不留存对象本身。例如，有一个类想要记录所有实例。这个需求可以使用弱引用实现，这是一种低层机制，是 weakref 模块中 WeakValueDictionary 、WeakKeyDictionary 和 WeakSet 等有用的集合类，以及 finalize 函数的底层支持。