## 上下文管理器

* 用处广泛的else：else 子句不仅能在 if 语句中使用，还能在 for 、while 和 try 语句中使用。
    * for：仅当 for 循环运行完毕时（即 for 循环没有被 break 语句中止）才运行 else 块。
    * while：仅当 while 循环因为条件为假值 而退出时（即 while 循环没有被 break 语句中止）才运行 else 块。
    * try：仅当 try 块中没有异常抛出时才运行 else 块

```    
在这些语句中使用 else 子句通常能让代码更易于阅读，而且能省去一些麻烦，不用设置控制标志或者添加额外的 if 语句。
```

* 上下文管理器和with块：with 语句的目的是简化 try/finally 模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、return 语句或 sys.exit() 调用而中止，也会执行指定的操作。上下文管理器协议包含 __enter__ 和 __exit__ 两个方法。with 语句开始运行时，会在上下文管理器对象上调用 __enter__ 方法。with 语句运行结束后，会在上下文管理器对象上调用 __exit__ 方法，以此扮演 finally 子句的角色。

``` 
不管控制流程以哪种方式退出 with 块，都会在上下文管理器对象上调用 __exit__ 方法，而不是在 __enter__ 方法返回的对象上调用。with 语句的 as 子句是可选的。
在__exit__里返回 True（没有return就默认为return False），就相当于告诉Python解释器，这个异常我们已经捕获了，不需要再往外抛了。
``` 

* @contextmanager：@contextmanager 装饰器能减少创建上下文管理器的样板代码量，因为不用编写一个完整的类，定义 __enter__ 和 __exit__ 方法，而只需实现有一个 yield 语句的生成器，生成想让 __enter__ 方法返回的值。yield 语句的作用是把函数的定义体分成两部分：yield 语句前面的所有代码在 with 块开始时（即解释器调用 __enter__ 方法时）执行， yield 语句后面的代码在 with 块结束时（即调用 __exit__ 方法时）执行。

* 总结起来，使用上下文管理器有三个好处：提高代码的复用率；提高代码的优雅度；提高代码的可读性；