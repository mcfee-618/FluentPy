## 字典相关

字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它

   - 可散列的数据类型：标准库里的所有映射类型都是利用 dict 来实现的，因此它们有个共同的限制，即只有可散列的 数据类型才能用作这些映射里的键（只有键有这个要求，值并不需要是可散列的数据类型）。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现 __hash__() 方法。另外可散列对象还要有 __qe__() 方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的
   
```
   对于不可变类型：
        原子不可变数据类型（str 、bytes 和数值类型）都是可散列类型，
        元组的话，只有当一个元组包含的所有元素都是可散列类型的情况下，它才是可散列的。
   对于用户自定义类型：
        用户自定义的类型的对象都是可散列的，散列值就是它们的 id() 函数的返回值，
        如果一个对象实现了 __eq__ 方法，在方法中用到了这个对象的内部状态，
        只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。
   创建字典：   
        >>> a = dict(one=1, two=2, three=3)
        >>> b = {'one': 1, 'two': 2, 'three': 3}
```

   - 字典推导：字典推导可以从任何以键值对作为元素的可迭代对象中构建出字典。
```   
   country_code = {country: code for code, country in DIAL_CODES} 
```

   - 常见方法：
```    
   get：用get(k, default) 来代替 d[k] ，给找不到的键一个默认的返回值（这比处理 KeyError 要方便不少）。
   setdefault：和 get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值
              dict.setdefault(key, default=None)  
   __missing__：当 __getitem__ 找不到对应键的时候，这个方法会被调用
```    

   - 映射的弹性键查询：有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。有两个途径能帮我们达到这个目的，一个是通过 defaultdict 这个类型而不是普通的 dict ，另一个是给自己定义一个 dict 的子类，然后在子类中实现 __missing__ 方法
    - 特殊方法__missing__:所有的映射类型在处理找不到的键的时候，都会牵扯到 __missing__方法。这也是这个方法称作“missing”的原因。虽然基类 dict 并没有定义这个方法，但是 dict 是知道有这么个东西存在的。也就是说，如果有一个类继承了 dict，然后这个继承类提供了 __missing__ 方法，那么在 __getitem__ 碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 KeyError 异常。

``` 
__missing__ 方法只会被 __getitem__ 调用（比如在表达式 d[k] 中）。
提供 __missing__ 方法对 get 或者__contains__（in 运算符会用到这个方法）这些方法的使用没有影响。
get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会
``` 

   - 字典的变种：
``` 
    collections.OrderedDict:'记住插入顺序的字典'
```     


##  集合运算

```
    交: x&y
    并: x|y
    差: x-y
    对称差集：x^y
    判断两个集合是否相交：x.isdisjoint(y) 若相交则返回False
    判断包含和被包含的关系： y0.issubset(y) ; y.issuperset(y0)
    x&y #x.intersection(y);y.intersetion(x)
    x|y #x.union(y)
    x-y #x.difference(y)
    x^y  #x.symmetric_difference(y)
    x.isdisjoint(y) #判断是否相交
    y0.issubset(y)  #判断y0是否是y的子集
    y.issuperset(y0)  #判断y是否是y0的超集
```

##  性能分析

* 字典性能：在一个有 1000 万个键的字典里查找 1000 个数，花在每个数上的时间不过是 0.337 微秒，set和字典的性能类似，列表就很慢了。

* 字典的实现

    * 散列表的基本思想：通过一定的函数将需要搜索的键值映射为一个整数，根据这个整数作为索引去访问某片连续的内存区域。用于映射的函数称为映射函数，映射所产生的值称为散列值（hash value）。散列函数对搜索效率有直接的决定性作用。在使用散列函数将不同的值可能映射到相同的散列值，这个时候就需要冲突解决（装载率大于2/3时，冲突的概率就会大大增加）
    
    * 底层数据结构：在 dict 的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。
    
    * 冲突解决：在python中使用的是开放定址法，就是通过一个二次探测函数f，计算下一个位置，一直到找到下一个可用的位置为止，在这个过程中会到达多个位置，这些位置就形成了一个“冲突探测链”，这个冲突探测链在查找某个元素的时候起到重要作用，所以在删除某个位置上的元素，不能直接将这个位置的内容删除，如果删除的话，则导致后续依赖于这个位置的其他值就都无法寻找到了，所以只能进行“伪删除”（通过给元素设置状态，dummy态，表示没有存储具体的值但是还会用到的废弃态）
    
    * 散列值和相等性:内置的 hash() 方法可以用于所有的内置类型对象。如果是自定义对象调用 hash()的话，实际上运行的是自定义的 __hash__ 。如果两个对象在比较的时候是相等的，那它们的散列值必须相等，否则散列表就不能正常运行了。一个可散列的对象必须满足以下要求。

        * 支持 hash() 函数，并且通过 __hash__() 方法所得到的散列值是不变的。
    
        * 支持通过 __eq__() 方法来检测相等性。
    
        * 若 a == b 为真，则 hash(a) == hash(b) 也为真。
        
    * 逻辑删除：每个entry有三种状态：Active, Unused, Dummy。哈希探测结束的条件是探测到一个Unused的entry。但是dict操作中必定会有删除操作，如果删除时仅把Active标记成Unused，显然该entry之后的所有entry都不可能被探测到，所以引入了dummy结构。遇到dummy就说明当前entry处于空闲状态，但探测不能结束。这样就解决了删除一个entry之后探测链断裂的问题。  
    
 * 字典的缺点   
    * 字典在内存上的开销巨大：由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下。速度是以牺     牲空间为代价而换来的。
    
    * 键的次序取决于添加顺序：添加顺序可能决定键的位置，对字典中添加新的键值可能导致扩容从而导致重新调整位置。
      由此可知，不要对字典同时进行迭代和修改。
      
    * 逻辑删除而不是物理删除：由于字典的实现是再hash的方法实现，因此物理删除元素会影响元素的探测，因此只能逻辑删除，并且这个地址还是不能再使用了，这样很浪费内存，如果导致扩容。