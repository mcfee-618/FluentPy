## 字典相关

字典这个数据结构活跃在所有 Python 程序的背后，即便你的源码里并没有直接用到它

   - 可散列的数据类型：标准库里的所有映射类型都是利用 dict 来实现的，因此它们有个共同的限制，即只有可散列的 数据类型才能用作这些映射里的键（只有键有这个要求，值并不需要是可散列的数据类型）。如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现 __hash__() 方法。另外可散列对象还要有 __qe__() 方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列值一定是一样的
   
```
   对于不可变类型：
        原子不可变数据类型（str 、bytes 和数值类型）都是可散列类型，
        元组的话，只有当一个元组包含的所有元素都是可散列类型的情况下，它才是可散列的。
   对于用户自定义类型：
        用户自定义的类型的对象都是可散列的，散列值就是它们的 id() 函数的返回值，
        如果一个对象实现了 __eq__ 方法，在方法中用到了这个对象的内部状态，
        只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。
   创建字典：   
        >>> a = dict(one=1, two=2, three=3)
        >>> b = {'one': 1, 'two': 2, 'three': 3}
```

   - 字典推导：字典推导可以从任何以键值对作为元素的可迭代对象中构建出字典。
```   
   country_code = {country: code for code, country in DIAL_CODES} 
```

   - 常见方法：
```    
   get：用get(k, default) 来代替 d[k] ，给找不到的键一个默认的返回值（这比处理 KeyError 要方便不少）。
   setdefault：和 get()方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值
              dict.setdefault(key, default=None)  
   __missing__：当 __getitem__ 找不到对应键的时候，这个方法会被调用
```    

   - 映射的弹性键查询：有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。有两个途径能帮我们达到这个目的，一个是通过 defaultdict 这个类型而不是普通的 dict ，另一个是给自己定义一个 dict 的子类，然后在子类中实现 __missing__ 方法
    - 特殊方法__missing__:所有的映射类型在处理找不到的键的时候，都会牵扯到 __missing__方法。这也是这个方法称作“missing”的原因。虽然基类 dict 并没有定义这个方法，但是 dict 是知道有这么个东西存在的。也就是说，如果有一个类继承了 dict，然后这个继承类提供了 __missing__ 方法，那么在 __getitem__ 碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 KeyError 异常。

``` 
__missing__ 方法只会被 __getitem__ 调用（比如在表达式 d[k] 中）。
提供 __missing__ 方法对 get 或者__contains__（in 运算符会用到这个方法）这些方法的使用没有影响。
get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败之前，还能通过 __missing__ 再给某个键一个机会
``` 

   - 字典的变种：
``` 
    collections.OrderedDict:'记住插入顺序的字典'
```     


##  集合运算

```
    交: x&y
    并: x|y
    差: x-y
    对称差集：x^y
    判断两个集合是否相交：x.isdisjoint(y) 若相交则返回False
    判断包含和被包含的关系： y0.issubset(y) ; y.issuperset(y0)
    x&y #x.intersection(y);y.intersetion(x)
    x|y #x.union(y)
    x-y #x.difference(y)
    x^y  #x.symmetric_difference(y)
    x.isdisjoint(y) #判断是否相交
    y0.issubset(y)  #判断y0是否是y的子集
    y.issuperset(y0)  #判断y是否是y0的超集
```

##  深入分析